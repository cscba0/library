---
title: Segment Tree                 
documentation_of: data_structure/segment_tree.hpp
---
要素の更新や区間に対する集約された値の取得を高速に行うことができるデータ構造です。

テンプレートパラメータ:
- `T`: 要素の型。
- `op`: 二項演算 (モノイド)。`T op(T, T)` の形式である必要があります。
- `e`: モノイドの単位元を返す関数。`T e()` の形式である必要があります。

# 使い方
## コンストラクタ

```cpp
SegmentTree(int n)
```

### 説明

サイズ `n` のセグメントツリーを構築します。初期値は全て単位元 `e()` です。

- `n`: 要素数。

### 計算量

$O(N)$

```cpp
SegmentTree(const std::vector<T>& _v)
```

### 説明

与えられた配列 `_v` を元にセグメントツリーを構築します。

- `_v`: 初期値となる要素の配列。

### 計算量

$O(N)$

## operator[]

```cpp
T operator[](int p) const
```

### 説明

インデックス `p` の要素の値を返します。

- `p`: 要素のインデックス (0-indexed)。
- 戻り値: インデックス `p` の要素の値。

### 制約

$0 \le p < N$ (構築時の要素数)

### 計算量

$O(1)$

## set

```cpp
void set(int p, T x)
```

### 説明

インデックス `p` の要素の値を `x` に更新します。

- `p`: 要素のインデックス (0-indexed)。
- `x`: 更新後の値。

### 制約

$0 \le p < N$ (構築時の要素数)

### 計算量

$O(\log N)$

## add

```cpp
void add(int p, T x)
```

### 説明

インデックス `p` の要素に `x` を加算します。これは特に加算モノイドの場合に便利ですが、一般のモノイドに対しても `v[p] = op(v[p], x)` のように動作します。

- `p`: 要素のインデックス (0-indexed)。
- `x`: 加算する値。

### 制約

$0 \le p < N$ (構築時の要素数)

### 計算量

$O(\log N)$

## operator()

```cpp
T operator()(int l, int r) const
```

### 説明

区間 `[l, r)` (半開区間) の要素に対する二項演算 `op` の結果を返します。

- `l`: 区間の開始インデックス (0-indexed)。
- `r`: 区間の終了インデックス (0-indexed)。
- 戻り値: 区間 `[l, r)` の要素に対する `op` の結果。

### 制約

$0 \le l \le r \le N$ (構築時の要素数)

### 計算量

$O(\log N)$

## max_right

```cpp
int max_right(int l, auto f) const
```

### 説明

インデックス `l` から開始して、条件 `f(op(v[l], v[l+1], ..., v[i]))` を満たす最大のインデックス `i` を見つけます。つまり、区間 `[l, i]` の集約値に対して `f` が `true` となる最大の `i+1` を返します。`f` は単調である必要があります。

- `l`: 検索を開始するインデックス (0-indexed)。
- `f`: 条件関数。`bool f(T)` の形式である必要があります。
- 戻り値: 条件を満たす最大の `i+1`。条件を満たす `i` が存在しない場合は `l` を返します。区間 `[l, N)` 全体が条件を満たす場合は `N` を返します。

### 制約

$0 \le l \le N$ (構築時の要素数)

### 計算量

$O(\log N)$

## min_left

```cpp
int min_left(int r, auto f) const
```

### 説明

インデックス `r` で終了して、条件 `f(op(v[i], ..., v[r-2], v[r-1]))` を満たす最小のインデックス `i` を見つけます。つまり、区間 `[i, r)` の集約値に対して `f` が `true` となる最小の `i` を返します。`f` は単調である必要があります。

- `r`: 検索を終了するインデックス (0-indexed)。
- `f`: 条件関数。`bool f(T)` の形式である必要があります。
- 戻り値: 条件を満たす最小の `i`。条件を満たす `i` が存在しない場合は `r` を返します。区間 `[0, r)` 全体が条件を満たす場合は `0` を返します。

### 制約

$0 \le r \le N$ (構築時の要素数)

### 計算量

$O(\log N)$
