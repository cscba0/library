---
title: Dynamic Segment Tree<br>
documentation_of: data_structure/dynamic_segment_tree.hpp
---
広大な範囲に対する要素の更新や区間に対する集約された値の取得を、実際に存在する要素のみをノードとして持つことで効率的に行うことができるデータ構造です。

テンプレートパラメータ:
- `T`: 要素の型。
- `op`: 二項演算 (モノイド)。`T op(T, T)` の形式である必要があります。
- `e`: モノイドの単位元を返す関数。`T e()` の形式である必要があります。
- `n`: 管理する区間の最大値 + 1 (デフォルトは $10^{18}$ 程度)。

# 使い方
## コンストラクタ

```cpp
DynamicSegmentTree()
```

### 説明

空の動的セグメントツリーを構築します。

### 計算量

$O(1)$

## set

```cpp
void set(int64_t p, T v)
```

### 説明

インデックス `p` の要素の値を `v` に更新します。インデックス `p` に対応するノードが存在しない場合は新しく作成されます。

- `p`: 要素のインデックス。
- `v`: 更新後の値。

### 制約

$0 \le p < n$

### 計算量

$O(\log n)$

## operator[]

```cpp
T operator[](int64_t p)
```

### 説明

インデックス `p` の要素の値を返します。インデックス `p` に対応するノードが存在しない場合は単位元 `e()` を返します。

- `p`: 要素のインデックス。
- 戻り値: インデックス `p` の要素の値、または単位元。

### 制約

$0 \le p < n$

### 計算量

$O(\log n)$

## operator()

```cpp
T operator()(int64_t L, int64_t R)
```

### 説明

区間 `[L, R)` (半開区間) の要素に対する二項演算 `op` の結果を返します。

- `L`: 区間の開始インデックス。
- `R`: 区間の終了インデックス。
- 戻り値: 区間 `[L, R)` の要素に対する `op` の結果。

### 制約

$0 \le L \le R \le n$

### 計算量

$O(\log n)$

## max_right

```cpp
int64_t max_right(int64_t L, const auto& f)
```

### 説明

インデックス `L` から開始して、条件 `f(op(v[L], v[L+1], ..., v[i]))` を満たす最大のインデックス `i` を見つけます。つまり、区間 `[L, i]` の集約値に対して `f` が `true` となる最大の `i+1` を返します。`f` は単調である必要があります。

- `L`: 検索を開始するインデックス。
- `f`: 条件関数。`bool f(T)` の形式である必要があります。
- 戻り値: 条件を満たす最大の `i+1`。条件を満たす `i` が存在しない場合は `L` を返します。区間 `[L, n)` 全体が条件を満たす場合は `n` を返します。

### 制約

$0 \le L \le n$

### 計算量

$O(\log n)$

## min_left

```cpp
int64_t min_left(int64_t R, const auto& f)
```

### 説明

インデックス `R` で終了して、条件 `f(op(v[i], ..., v[R-2], v[R-1]))` を満たす最小のインデックス `i` を見つけます。つまり、区間 `[i, R)` の集約値に対して `f` が `true` となる最小の `i` を返します。`f` は単調である必要があります。

- `R`: 検索を終了するインデックス。
- `f`: 条件関数。`bool f(T)` の形式である必要があります。
- 戻り値: 条件を満たす最小の `i`。条件を満たす `i` が存在しない場合は `R` を返します。区間 `[0, R)` 全体が条件を満たす場合は `0` を返します。

### 制約

$0 \le R \le n$

### 計算量

$O(\log n)$
