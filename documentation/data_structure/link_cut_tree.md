---
title: Link-Cut Tree
documentation_of: data_structure/link_cut_tree.hpp
---
動的な木に対する操作（辺の追加・削除、パス上の集約値取得など）を高速に行うことができるデータ構造です。

テンプレートパラメータ:
- `T`: 要素の型。
- `op`: 二項演算 (モノイド)。`T op(T, T)` の形式である必要があります。
- `e`: モノイドの単位元を返す関数。`T e()` の形式である必要があります。

# 使い方
## add

```cpp
void add(T x)
```

### 説明

新しいノードに値 `x` を追加します。ノードのインデックスは追加された順に0から割り当てられます。

- `x`: 追加する要素の値。

### 計算量

$O(1)$

## link

```cpp
void link(int u, int v)
```

### 説明

ノード `u` とノード `v` の間に辺を追加し、2つの木を連結します。`u` は根である必要があります。

- `u`: 辺を追加するノードのインデックス (0-indexed)。根である必要がある。
- `v`: 辺を追加するノードのインデックス (0-indexed)。

### 制約

- `u` と `v` は異なる木に属している必要があります。
- `u` はその木において根である必要があります。

### 計算量

$O(\\log N)$ (amortized)

## expose

```cpp
void expose(nptr& ptr)
```

### 説明

ノード `ptr` をその属する木の根からの優先パスの最上部に持ち上げます。これにより、根から `ptr` までのパスがSplay Treeとして表現されます。

- `ptr`: exposeするノードへのポインタ。

### 計算量

$O(\\log N)$ (amortized)

## evert

```cpp
void evert(nptr ptr)
```

### 説明

ノード `ptr` をその属する木の新しい根とします。

- `ptr`: 新しい根とするノードへのポインタ。

### 計算量

$O(\\log N)$ (amortized)

## cut

```cpp
void cut(int U, int V)
```

### 説明

ノード `U` とノード `V` の間の辺を削除します。`U` は `V` の親である必要があります。

- `U`: 辺を削除するノードのインデックス (0-indexed)。`V` の親である必要がある。
- `V`: 辺を削除するノードのインデックス (0-indexed)。

### 制約

- `U` と `V` は同じ木に属している必要があります。
- `U` は `V` の親である必要があります。

### 計算量

$O(\\log N)$ (amortized)

## set

```cpp
void set(int U, T x)
```

### 説明

ノード `U` の値を `x` に更新します。

- `U`: 値を更新するノードのインデックス (0-indexed)。
- `x`: 更新後の値。

### 計算量

$O(\\log N)$ (amortized)

## operator[]

```cpp
T operator[](int U)
```

### 説明

ノード `U` の値を返します。

- `U`: 値を取得するノードのインデックス (0-indexed)。
- 戻り値: ノード `U` の値。

### 計算量

$O(\\log N)$ (amortized)

## operator()

```cpp
T operator()(int U, int V)
```

### 説明

ノード `U` とノード `V` の間のパス上の値の集約結果を返します。`U` を根とする木において、`V` までのパスの集約値を取得します。

- `U`: パスの開始ノードのインデックス (0-indexed)。根である必要がある。
- `V`: パスの終了ノードのインデックス (0-indexed)。
- 戻り値: パス上の値の集約結果。

### 制約

- `U` と `V` は同じ木に属している必要があります。
- `U` はその木において根である必要があります。

### 計算量

$O(\\log N)$ (amortized)

